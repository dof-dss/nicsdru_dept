<?php

/**
 * @file
 * Primary module hooks for Dept Publications module.
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\Core\StringTranslation\ByteSizeMarkup;
use Drupal\Core\Url;
use Drupal\file\FileInterface;
use Drupal\media\MediaInterface;
use Drupal\views\Render\ViewsRenderPipelineMarkup;
use GuzzleHttp\Exception\RequestException as GuzzleRequestException;

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function dept_publications_form_node_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  /** @var \Drupal\Core\Entity\EntityFormInterface $form_object */
  $form_object = $form_state->getFormObject();
  /** @var \Drupal\node\NodeInterface $node */
  $node = $form_object->getEntity();

  // Toggle the display/availability of fields depending on the required
  // attachment type.
  if ($node->bundle() === 'publication') {
    if ($node->isNew() === FALSE) {
      $form['field_embargoed']['#disabled'] = TRUE;
    }

    $current_user = \Drupal::currentUser();
    // Allow the selection of 'Public' or 'Secure' publications.
    if ($current_user->hasPermission('create embargoed publication') || in_array('administrator', $current_user->getRoles())) {
      $form['field_publication_files']['#states'] = [
        'invisible' => [
          ':input[id="edit-field-embargoed-value"]' => ['checked' => TRUE],
        ],
      ];
      $form['field_external_publication']['#states'] = [
        'invisible' => [
          ':input[id="edit-field-embargoed-value"]' => ['checked' => TRUE],
        ],
      ];

      $form['field_publication_secure_files']['#states'] = [
        'invisible' => [
          ':input[id="edit-field-embargoed-value"]' => ['checked' => FALSE],
        ],
        'required' => [
          ':input[id="edit-field-embargoed-value"]' => ['checked' => TRUE],
        ],
      ];
    }
    else {
      // Set the publication type to 'public' and prevent access to the
      // embargoed publication widget if the user does not have the
      // 'Create embargoed' permission or is non-admin.
      $form['field_embargoed'] = [
        '#type' => 'hidden',
        '#default_value' => '0',
        '#value' => '0',
      ];

      $form['field_publication_secure_files']['#access'] = FALSE;
    }

    $form['#validate'][] = 'dept_publications_validate_publication';
  }
}

/**
 * Form validation callback.
 */
function dept_publications_validate_publication(&$form, FormStateInterface $form_state) {
  $values = $form_state->getValues();

  // Validate public and secure file attachments.
  if ($values['field_embargoed'] == 0) {
    if (empty($values['field_publication_files']["selection"][0]) && empty($values['field_external_publication'][0]['uri'])) {
      $form_state->setErrorByName('field_publication_files', t('You must provide an attachment or external link'));
      $form_state->setErrorByName('field_external_publication', t('You must provide an attachment or external link'));
    }
  }
  else {
    if (empty($values['field_publication_secure_files']['selection'])) {
      $form_state->setErrorByName('field_publication_secure_files', t('You must provide a secure attachment'));
    }
  }
}

/**
 * Implements hook_file_download().
 */
function dept_publications_file_download($uri) {
  // Return -1 which is then later converted to AccessDeniedHttpException response.
  if (\Drupal::service('secure_publications_file_access')->canAccessSecureFileAttachment($uri) === FALSE) {
    return -1;
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function dept_publications_form_views_exposed_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  if (str_starts_with($form['#id'], 'views-exposed-form-media-library') &&
    \Drupal::currentUser()->hasPermission('view any embargoed publication')) {
    // Permit secure files in exposed filter. Dovetails with
    // dept_publications_views_query_alter above.
    $form['type']['#options']['secure_file'] = t('Secure file');
    ksort($form['type']['#options']);
  }
}

/**
 * Implements hook_preprocess_views_view_field().
 */
function dept_publications_preprocess_views_view_field(&$variables) {
  $view = $variables['view'];
  $field_id = $variables['field']->field;

  // If a publication is embargoed and unpublished, update the 'content type' text.
  if ($view->storage->id() === 'workflow_moderation' || $view->storage->id() === 'content') {
    if ($variables['field']->field === 'type' && $variables['output'] == 'Publication') {
      $entity = $variables["row"]->_entity;
      if (!$entity->isPublished() && $entity->hasField('field_embargoed') && $entity->get('field_embargoed')->getString()) {
        $variables['output'] = t('Publication (embargoed)');
      }
    }
  }

  // Fill in any remote-docs metadata if they're listed.
  if ($view->id() === 'media_library' && in_array($view->current_display, ['default_page', 'widget_table'])) {
    if ($field_id === 'filemime' && empty($variables['output'])) {
      // If empty, try checking mime type for an image.
      $media = $variables['row']->_entity;

      if ($media instanceof MediaInterface && $media->bundle() === 'remote_document') {
        $pretty_mimes = \Drupal::service('origins_media.pretty_mime_types')
          ->getMimeTypes();
        $file_url = $media->get('field_media_media_remote')->getString();
        $file_headers = dept_publications_get_remote_file_metadata($file_url);

        if ($file_headers) {
          $file_mimetype = '';

          // Get file mimetype if available.
          if (!empty($file_headers['Content-Type'])) {
            $file_mimetype = $file_headers['Content-Type'][0] ?? '';
          }

          // Map file mimetypes to user friendly document types.
          if ($file_mimetype && !empty($pretty_mimes[$file_mimetype])) {
            $mime_type_key = $pretty_mimes[$file_mimetype];

            // Replace with prettier version.
            $variables['output'] = ViewsRenderPipelineMarkup::create($mime_type_key);
          }
        }
      }
    }
  }
}

/**
 * Implements hook_preprocess_media().
 */
function dept_publications_preprocess_media(&$variables) {
  if ($variables['media']->bundle() === 'remote_document' && $variables['view_mode'] === 'embed') {
    /* @var \Drupal\Core\Url $url */
    $url = $variables['content']['field_media_media_remote'][0]['#url'];

    if ($url instanceof Url) {
      $file_url = $url->getUri();
    }
    else {
      // No URL to work with for whatever reason so return early.
      return;
    }

    // Full URL string for use in later preprocessing.
    $variables['file_url'] = $file_url;

    $file_headers = dept_publications_get_remote_file_metadata($file_url);

    // Initialize metadata variables.
    $file_size = 0;
    $file_mimetype = '';
    $file_extension = '';
    $file_type = '';

    if ($file_headers) {
      // Get file size if available.
      if (!empty($file_headers['Content-Length'])) {
        $file_size = $file_headers['Content-Length'][0] ?? 0;
      }

      // Get file mimetype if available.
      if (!empty($file_headers['content-type'])) {
        $file_mimetype = $file_headers['content-type'][0] ?? '';
      }

      // Get file extension.
      $path_info = pathinfo(parse_url($file_url, PHP_URL_PATH));
      if (!empty($path_info['extension'])) {
        $file_extension = $path_info['extension'] ?? '';
      }
    }

    // Example: Add these values to the $variables array for later use in the template.
    $variables['file_size_raw'] = $file_size;
    $variables['file_size'] = ByteSizeMarkup::create($file_size);
    $variables['file_mimetype'] = $file_mimetype;
    $variables['file_extension'] = $file_extension;

    // Map file mimetypes to user friendly document types.
    $pretty_mimes = \Drupal::service('origins_media.pretty_mime_types')
      ->getMimeTypes();
    if ($file_mimetype && !empty($pretty_mimes[$file_mimetype])) {
      $variables['pretty_mimetype'] = $pretty_mimes[$file_mimetype];
    }

    if (array_key_exists($file_mimetype, $pretty_mimes)) {
      $variables['file_type'] = $pretty_mimes[$file_mimetype];
    }
    else {
      $variables['file_type'] = strtoupper(preg_replace('/^application\/(\w+)$/', '\1', $file_mimetype));
    }

    // Add an extra 'is external' preprocess variable so we can distinguish it
    // when rendering markup in the template.
    $variables['file_is_external'] = (bool) preg_match('/^http/', $file_url);

    $variables['media_langcode'] = $variables['media']->language()->getId();
    // Do not output the langcode if is undefined.
    if ($variables['media_langcode'] === 'und') {
      unset($variables['media_langcode']);
    }
  }
}

/**
 * Function to fetch HTTP headers from a remote file URL.
 */
function dept_publications_get_remote_file_metadata(string $file_url) {
  // Fetch metadata about the file.
  $http_client = \Drupal::httpClient();

  $file_headers = [];

  try {
    $file_headers = $http_client->request('HEAD', $file_url)->getHeaders();
  }
  catch (GuzzleRequestException $reqex) {
    $message = t('Could not retrieve headers from :file_url', [':file_url' => $file_url]);
    if (\Drupal::currentUser()->isAuthenticated()) {
      \Drupal::messenger()->addWarning($message);
    }

    \Drupal::logger('warning')->warning($message);
  }

  return $file_headers;
}

/**
 * Implements hook_preprocess_fieldset__media_library_widget().
 */
function dept_publications_preprocess_fieldset__media_library_widget(&$variables) {
  // Add custom style overrides to the media library field widget.
  $variables['#attached']['library'][] = 'dept_publications/media_widget_styles';
}

/**
 * <<<<<<< HEAD
 * Implements hook_node_grants().
 */
function dept_publications_node_grants(AccountInterface $account, $op) {
  /** @var array $grants_cache */
  $grants_cache = &drupal_static(__FUNCTION__, []);
  if (isset($grants_cache[$account->id()][$op])) {
    return $grants_cache[$account->id()][$op];
  }

  $grants = [];

  // Grants for access control to embargoed, unpublished publications.
  switch ($op) {
    case 'view':
      if ($account->hasPermission('view any embargoed publication')) {
        $grants['view_embargoed_publications'][] = 1;
      }
      elseif ($account->hasPermission('view own embargoed publication')) {
        $grants['embargoed_publication_author'][] = $account->id();
      }
      break;

    case 'update':
      if ($account->hasPermission('edit any embargoed publication')) {
        $grants['edit_embargoed_publications'][] = 1;
      }
      elseif ($account->hasPermission('edit own secure publication')) {
        $grants['embargoed_publication_author'][] = $account->id();
      }
      break;

    case 'delete':
      if ($account->hasPermission('delete any secure publication')) {
        $grants['delete_embargoed_publications'][] = 1;
      }
      elseif ($account->hasPermission('delete own secure publication')) {
        $grants['embargoed_publication_author'][] = $account->id();
      }
      break;
  }

  $grants_cache[$account->id()][$op] = $grants;
  return $grants_cache[$account->id()][$op];
}

/**
 * Implements hook_node_access_records_alter().
 */
function dept_publications_node_access_records_alter(&$grants, $node) {
  // Creates access records for embargoed publications.
  // See: https://digitaldevelopment.atlassian.net/wiki/x/AQCNkg
  if ($node->bundle() === 'publication') {
    $embargoed = $node->get('field_embargoed')->getString();

    if ($embargoed && $node->isPublished() === FALSE) {
      $grants = [];

      $grants[] = [
        'realm' => 'view_embargoed_publications',
        'gid' => 1,
        'grant_view' => 1,
        'grant_update' => 0,
        'grant_delete' => 0,
        'priority' => 0,
      ];

      $grants[] = [
        'realm' => "edit_embargoed_publications",
        'gid' => 1,
        'grant_view' => 1,
        'grant_update' => 1,
        'grant_delete' => 0,
        'priority' => 0,
      ];

      $grants[] = [
        'realm' => "delete_embargoed_publications",
        'gid' => 1,
        'grant_view' => 1,
        'grant_update' => 0,
        'grant_delete' => 1,
        'priority' => 0,
      ];

      $grants[] = [
        'realm' => 'embargoed_publication_author',
        'gid' => $node->getOwnerId(),
        'grant_view' => 1,
        'grant_update' => 1,
        'grant_delete' => 1,
        'priority' => 0,
      ];
    }
  }

  /**
   * Implements hook_preprocess_node().
   */
  function dept_publications_preprocess_node(&$variables) {
    /* @var \Drupal\node\NodeInterface $node */
    $node = $variables['node'];

    if ($node->bundle() != 'publication') {
      return;
    }

    $items = [];

    // 1. field_external_publication (Link field)
    if (!$node->get('field_external_publication')->isEmpty()) {
      foreach ($node->get('field_external_publication') as $link_item) {
        $title = $link_item->title ?? $link_item->uri;
        $url = Url::fromUri($link_item->uri);

        $items[] = dept_publications_build_publication_link($url, $title, [
          'file_extension' => 'html',
          'file_type' => 'html',
        ]);
      }
    }

    // 2. field_publication_files (Media reference)
    if (!$node->get('field_publication_files')->isEmpty()) {
      foreach ($node->get('field_publication_files')
        ->referencedEntities() as $media) {
        $title = $media->label();
        $file_info = [];
        $url = '';

        if ($media->hasField('field_media_file') && !$media->get('field_media_file')->isEmpty()) {
          $file = $media->get('field_media_file')->entity;
          $url = Url::fromUri(\Drupal::service('file_url_generator')
            ->generateAbsoluteString($file->getFileUri()));

          $file_info = dept_publications_map_filetypes_to_document_types($file);
        }

        $items[] = dept_publications_build_publication_link($url, $title, $file_info);
      }
    }

    // 3. field_publication_secure_files (Media reference)
    if (!$node->get('field_publication_secure_files')->isEmpty()) {
      foreach ($node->get('field_publication_secure_files')
        ->referencedEntities() as $media) {
        $title = $media->label();
        $file_info = [];
        $url = '';

        if ($media->hasField('field_media_file_1') && !$media->get('field_media_file_1')->isEmpty()) {
          $file = $media->get('field_media_file_1')->entity;
          $url = Url::fromUri(\Drupal::service('file_url_generator')
            ->generateAbsoluteString($file->getFileUri()));

          $file_info = dept_publications_map_filetypes_to_document_types($file);
        }

        $items[] = dept_publications_build_publication_link($url, $title, $file_info);
      }
    }

    // Wrap in an item list.
    $rendered = [
      '#theme' => 'item_list',
      '#items' => $items,
      '#attributes' => ['class' => ['list--no-bullet']],
    ];

    // Make available in template.
    $variables['aggregated_publications'] = $rendered;
  }

}

/**
 * Helper function to build render array for a publication item.
 *
 * @param \Drupal\Core\Url $url
 *   The URL object.
 * @param string $title
 *   The text to display for the link.
 * @param array $file_info
 *   Type of file (e.g. 'pdf', 'docx', 'html') for CSS classes as well as filesize.
 *
 * @return array
 *   A renderable array.
 */
function dept_publications_build_publication_link(Url $url, string $title, array $file_info): array {
  $link_text = [
    '#markup' => $title,
  ];

  // Append the metadata span if provided.
  if (!empty($file_info['file_type']) && !empty($file_info['file_size'])) {
    $link_text[] = [
      '#markup' => '<span class="meta">' . $file_info['file_type'] . ' (' . $file_info['file_size'] . ')</span>',
    ];
  }

  return [
    '#type' => 'link',
    '#title' => $link_text,
    '#url' => $url,
    '#attributes' => [
      'lang' => 'en',
      'class' => [
        'file-link',
        'file--ico',
        "file--ico__{$file_info['file_extension']}",
      ],
      'rel' => ['noopener', 'noreferrer'],
      'target' => '_blank',
      'data-once' => 'elink',
    ],
  ];
}

/**
 * Helper function to map file mimetypes to user friendly document types.
 */
function dept_publications_map_filetypes_to_document_types(FileInterface $file) {
  $pretty_mimes = \Drupal::service('origins_media.pretty_mime_types')->getMimeTypes();

  $file_info = [];
  $file_info['file_size'] = ByteSizeMarkup::create($file->getSize(), \Drupal::languageManager()->getCurrentLanguage()->getId());

  $file_info['file_url'] = $file->createFileUrl();
  $file_info['file_extension'] = strtolower(pathinfo($file_info['file_url'], PATHINFO_EXTENSION));

  $file_mimetype = $file->getMimeType();
  if (array_key_exists($file->getMimeType(), $pretty_mimes)) {
    $file_info['file_type'] = $pretty_mimes[$file_mimetype];
  }
  else {
    $file_info['file_type'] = strtoupper(preg_replace('/^application\/(\w+)$/', '\1', $file_mimetype));
  }

  return $file_info;
}
